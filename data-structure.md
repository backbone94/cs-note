## 자료구조
자료구조는 데이터를 효율적으로 저장하고 관리하기 위한 개념이다. 프로그램을 설계할 때, 자료구조에 의해서 프로그램의 성능이 결정되기도 하며 메모리 사용의 효율성에도 큰 영향을 미치므로 프로그램 설계에서 자료구조는 매우 중요하다. 따라서 데이터의 성격에 따라 적절한 자료구조를 선택해야 한다. 기본적인 자료구조에는 스택, 큐, 배열, 연결 리스트, Set이 있으며, 추상적인 자료구조에는 해시 테이블, 그래프, 트리, 힙, 우선순위 큐가 있다.

### 스택
LIFO(Last In First Out) 즉, 가장 마지막에 들어간 데이터가 가장 먼저 나오는 자료구조이다. 주요 연산으로는 push(), pop(), peek()이 있으며 각각의 기능은 데이터 삽입, 추출, 조회이다. 웹 브라우저의 뒤로 가기 기능은 스택의 개념을 기반으로 만들어졌다.
구현이 상대적으로 간단하며, 함수의 호출 등 재귀 알고리즘에 적합하다.
Stack의 가장 마지막 요소에만 접근 가능하며, 그로 인해서 중간에 위치하는 요소를 한 번에 접근할 수 없다는 것이 단점이다.

---

### 큐
FIFO(First In First Out) 즉, 가장 먼저 들어간 데이터가 가장 먼저 나오는 자료구조이다.
주요 연산으로는 enqueue(), dequeue(), peek()이 있으며 각각의 기능은 데이터 삽입, 추출, 조회이다. 프린터 대기열, 네트워크 패킷 처리를 예시로 들 수 있다.
데이터 처리 순서가 직관적이며 자원이 한정되어 있을 경우 큐를 통해 작업 대기열을 관리하기 좋다.
하지만 큐의 앞쪽 요소에만 접근 가능하며, 그로 인해서 중간에 위치하는 요소를 한 번에 접근할 수 없다는 것이 단점이다.

---

### 배열
순서를 가지는 데이터 집합으로, 각각의 데이터는 인덱스를 통해 한 번에 접근할 수 있으므로 O(1)의 시간 복잡도를 가진다. 중복되는 데이터가 저장되는 것을 허용하며, 메모리에 연속적으로 저장된다는 특징이 있다. 순서를 가지므로 큐와 비슷하게 대기열 관리에 적합한 자료구조이다.
데이터가 순차적으로 저장되어 있으므로 인덱스를 통한 빠른 요소 접근이 가능하다.
하지만 배열 중간에 요소를 삽입하려고 하면, 기존에 존재하던 요소들의 위치를 이동시켜야 하므로 데이터 삽입, 삭제의 비용이 적지 않다.

---

### 연결 리스트
여러 개의 노드가 연결되어 있는 리스트이다. 데이터가 노드에 저장되며, 각 노드는 다음 노드에 대한 참조 포인터를 가짐으로써 리스트가 된다. 연결 리스트의 첫 노드는 헤드(Head)로 불리며, 가장 마지막에 붙어 있는 노드는 꼬리(Tail)라고 불리운다. 각 노드가 오직 다음 노드에 대한 참조만을 가지고 있는 단일 연결 리스트, 각 노드가 이전 노드와 다음 노드에 대한 참조 모두를 가지고 있는 이중 연결 리스트, 마지막 노드가 첫 노드에 대한 참조를 가지고 있는 원형 연결 리스트가 있다. 연결 리스트는 트리와 그래프 구현에 직접적으로 쓰인다.
연결 리스트는 배열과 달리 크기가 동적으로 변경될 수 있으며, 데이터의 삽입, 삭제는 O(1)의 시간 복잡도를 가진다.
하지만 특정 노드로의 접근을 위해서, 항상 헤드에서부터 순차적으로 접근해야 한다는 단점이 있으며, 노드 이외에도 다음 노드에 대한 참조 포인터를 항상 가지고 있어야 하므로 추가 메모리 사용에 대한 부담이 존재할 수 있다.

---

### Set
Map과 비슷한 자료구조이지만 Set은 값(value)으로만 데이터가 이루어져 있다는 점이 차이점이다. 따라서 값의 중복을 허용하는 Map과 달리, Set은 데이터의 중복을 전혀 허용하지 않는다는 특징이 있다. 중복되지 않는 데이터 유지를 위해서 활용하기 좋다.
중복을 허용하지 않으므로 중복된 데이터가 저장될 시 중복을 자동으로 제거한다. 중복 제거를 통해 특정 값의 존재 여부를 빠르게 확인할 때 자주 쓰인다.
인덱스를 가지고 있지 않아, 인덱스를 통한 빠른 접근이 불가능하다. 또한 해시 함수를 사용하여 데이터를 저장하므로 해시 충돌이 발생할 경우 성능이 저하될 수 있다.

---

### 해시 테이블
키(key)와 값(value)의 쌍으로 이루어져 있는 자료구조이며 키가 인덱스 역할을 한다. 키를 해시 함수에 적용하여 해시 값을 추출하면, 그 값에 따라서 저장될 메모리의 주소가 결정된다. 따라서 추출된 해시 값이 이미 메모리에 저장이 되어 있는 데이터의 해시 값과 충돌하는 해시 충돌이 발생할 수 있다. 오픈 어드레싱, 체이닝과 같은 방법으로 해시 충돌을 해결한다. 해시 테이블에서는 요소의 순서가 존재하지 않으며 키가 고유하여 중복을 허용하지 않지만 값은 중복될 수 있다. 키가 인덱스 역할을 하므로 데이터 조회의 시간 복잡도는 O(1)이다.
키를 통해 빠른 데이터 조회가 가능하며 키와 값이 연결되어 있으므로 효율적인 데이터 관리를 할 수 있다.
그러나 데이터의 순서가 존재하는 배열과 달리, 해시 테이블은 데이터의 순서가 존재하지 않으므로 순차적인 데이터 처리가 어려울 수 있다. 또한 해시 충돌이 많이 발생하면 그만큼 성능이 저하된다.

---

### 그래프
데이터를 저장하고 있는 노드와 노드를 연결해주는 간선으로 이루어져 있으며 데이터 간의 관계를 표현하는 자료구조이다. 데이터가 서로 연결되어 있으므로 네트워크 구조 등을 나타내는데 적합하다. 노드에 연결되어 있는 간선의 수를 차수, 한 노드에서 다른 노드로 이어지는 노드들의 순서를 경로, 마지막 노드와 처음 노드가 연결되어 있는 경로를 사이클이라고 한다. 간선은 방향의 유무에 따라 무방향 그래프, 방향 그래프로 나뉘고, 간선에 가중치가 적용되어 있으면 가중치 그래프라고 한다.
그래프는 2차원 배열(=인접 행렬) 또는 리스트로 표현되어 계산에 사용될 수 있다. 

---

### 트리
노드에 데이터가 저장되고 각각의 노드는 간선에 의해 부모-자식 관계로 연결되어 있는 자료구조 그래프의 유형 중 하나이다. 데이터를 계층적으로 저장하고 있으므로 데이터의 빠른 탐색, 삽입, 삭제를 필요로 하는 경우에 쓰이는 자료구조이다. 트리는 그래프의 일종이지만 사이클이 존재하지 않는 그래프이다. 루트 노드는 하나이며 루트 노드로부터 트리가 시작된다.
데이터의 계층적 관계를 표현하기에 적합하며 데이터의 변경에 유연하다.
하지만 트리가 한쪽으로 치우져 있으면 최악의 경우에는 데이터의 검색, 삽입, 삭제의 시간 복잡도가 선형 시간(O(n))이 될 수 있다는 점을 주의해야 한다.
트리의 종류에는 이진 트리, 이진 탐색 트리, AVL 트리, 힙 등이 있다.

#### 이진 트리
각 노드가 최대 두 개의 자식 노드를 가질 수 있는 트리이다. 왼쪽부터 차례대로 노드가 배치된 완전 이진 트리, 모든 레벨이 완전히 채워진 포화 이진 트리 등이 있다. 루트 노드의 레벨은 0이다.

#### 이진 탐색 트리
BST(Binary Search Tree)라고 불리며 이진 트리의 특수한 형태로, 왼쪽 서브트리의 모든 노드 값은 부모 노드 값보다 항상 작고, 오른쪽 서브트리의 모든 노드 값은 부모 노드 값보다 항상 크다. 이러한 구조적 특징으로 O(log n)의 시간 복잡도로 데이터의 검색, 삽입, 삭제 연산을 수행할 수 있다.

#### AVL 트리
모든 노드의 왼쪽 서브트리와 오른쪽 서브트리의 높이 차이가 1 이하로 균형이 항상 잡히도록 유지되는 트리

#### 힙
완전 이진 트리의 일종으로, 부모 노드의 값이 자식 노드의 값보다 크거나 같은 '최대 힙', 부모 노드의 값이 자식 노드의 값보다 작거나 같은 '최소 힙'으로 나뉜다. 주로 '우선순위 큐'를 구현할 때 사용된다. O(log n)의 속도로 데이터의 검색, 삽입, 삭제 연산을 수행할 수 있다.

#### 우선순위 큐
큐의 일종으로, FIFO 방식을 기반으로 데이터를 처리하는 일반적인 큐와 달리, 각 노드가 가지는 값을 우선순위로써 사용하여, 우선순위가 가장 높은 노드를 먼저 처리하는 자료구조이다. 힙이 O(log n)의 시간 복잡도를 가지므로 우선순위 큐를 효율적으로 구현할 수 있다. 따라서 대부분의 우선순위 큐는 힙으로 구현된다. '다익스트라 알고리즘', '허프만 코딩'에서 우선순위 큐의 응용을 확인할 수 있다.
